# core
from typing import Annotated, Literal, TypeAlias

# dependencies
import numpy as np 			# maths
import numpy.typing as npt	# typing for numpy

Point: TypeAlias = Annotated[list[float], len(2)] | tuple[float, float]
Line: TypeAlias = list[Point] | npt.NDArray[np.float64]
Vertices: TypeAlias = list[list[float]] | npt.NDArray[np.float64]


def _generateIrregularStar(N: int) -> Vertices: ...
def _generateConvexPolygon(N: int) -> Vertices: ...
def _generatePolygon(N: int) -> Vertices: ...
def _generateUnitRectangle(epsilon: float) -> Vertices: ...
# def _generateUnitTriangle(r: float, theta: float) -> Vertices: ...
def _isColinear(V: Vertices) -> bool: ...
def _isConvex(V: Vertices) -> bool: ...
def _isPointInsideConvexPolygon(p: Point, V: Vertices) -> bool: ...
def _isPointInsidePolygon(p: Point, V: Vertices) -> bool: ...
def _isSimple(V: Vertices) -> bool: ...
def _largestVector(V: Vertices) -> tuple[float, tuple[int, int]]: ...
def _lineIntersection(A: Line, B: Line) -> tuple[
	Literal['adjacent', 'colinear', 'intersect', 'none', 'vertex'],
	Point,
]: ...
def _normaliseConvexPolygon(V: Vertices, signed_norm: bool) -> Vertices: ...
def _normalisePolygon(V: Vertices, signed_norm: bool) -> Vertices: ...
def _normaliseSimplePolygon(V: Vertices, signed_norm: bool) -> Vertices: ...
def _polygonArea(V: Vertices) -> float: ...
def _polygonCentroid(V: Vertices) -> Point: ...
def _scalePolygonByArea(V: Vertices, a: float) -> Vertices: ...
